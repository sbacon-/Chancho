<!DOCTYPE html>
<html lang="en-us">
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <!-- CHANCHO.DEV -->
    <title>Chancho.dev</title>
    <link rel="icon" href="res/favicon.png">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=VT323&display=swap" rel="stylesheet">

    <!-- CSS & JavaScript -->
    <link rel="stylesheet" type="text/css" href='/res/styles/deStijl.css?v=1'>
    <script type="text/javascript" src="/res/scripts/scripts.js"></script>
    <link rel="stylesheet" href="TemplateData/style.css">
    <script src="https://kit.fontawesome.com/f979a6de37.js" crossorigin="anonymous"></script>

    <!--[if lt IE 9]>
      <script src="styles/html5shiv.js"></script>
    <![endif]-->
    </head>
  <body>
    <header class="clearfix" role="banner">
      <h1 id="sitename"><a href="/">CHANCHO<em>.dev</em></a></h1>
      <h1><a href="https://github.com/sbacon-"><i class="fab fa-github" id="sitename" style="position:absolute;top:0px;right:0px;"></i></a></h1>
      <nav role="navigation">
      <ul>
        <li><a href="/">Home</a></li>
        <li><a onclick="displayNav()">Projects</a>
        <div style="position:absolute"><span id='projects'>
        </span></div></li>
        <li><a href="/About.html">About</a></li>
      </ul>
      </nav>
    </header>
    <article>
    <!--GAME TITLE-->
    <h2>Sort Algorithm Visualizer</h2>
    <div class="center">
    <div id="unity-container" class="unity-desktop">
      <canvas id="unity-canvas"></canvas>
      <div id="unity-loading-bar">
        <div id="unity-logo"></div>
        <div id="unity-progress-bar-empty">
          <div id="unity-progress-bar-full"></div>
        </div>
      </div>
      <div id="unity-mobile-warning">
        WebGL builds are not supported on mobile devices.
      </div>
      <div id="unity-footer">
        <div id="unity-webgl-logo"></div>
        <div id="unity-fullscreen-button"></div>
        <div id="unity-build-title">CUR2R5</div>
      </div>
    </div>
  </div>
    <!--GAME TEXT-->
  <p>
  <h3>Sort Algorithms</h3><br>
<u>Bubble Sort</u> - <strong>O(n<sup>2</sup>)</strong> Comparisons, <strong>O(n<sup>2</sup>)</strong> Swaps <br> 
The least efficient of the sort methods will simply compare the first node with it's neighbor.
Swapping if it is greater than it's neighboring node. This process is repeated until it reaches the last unsorted node. 
When the last unsorted node is at index 0, the node is ,in fact, sorted by omission.
This sort algorithm can be useful when the array is quite small, as the code is simple, however becomes very slow as <em> n </em> increases.
<br><br>
<u>Selection Sort</u> - <strong>O(n<sup>2</sup>)</strong> Comparisons, <strong>O(n)</strong> Swaps <br> 
Is a marginally more efficient algorithm, starting at the first unsorted node, the script will loop through and determine
the minimum node and move it to the start of the array. It is considered more efficent than the bubble sort as the
node is only swapped once the end of the array is reached. It is similar to bubble sort in that the code is very simple, but ineffective
when working with larger sets of data.
<br><br>
<u>Insertion Sort</u> - <strong>O(n<sup>2</sup>)</strong> Comparisons, <strong>O(n<sup>2</sup>)</strong> Swaps <br>
Though the average efficiency is comperable to the previous two sort algorithms, the insertion sort tends to sort slightly
faster. Starting at the first unsorted element it will work backwards until it finds a node that has a higher value. This can reduce
comparisons in a best case scenario where the unsorted node is higher than the next node. Another useful property of the 
insertion sort algorithm is that unsorted elements can be continually added. This is useful in the case of a high-score board, where it would be 
inefficient to sort the entire list to add a single entry.
<br><br>
<u>Merge Sort</u> - <strong>Θ(n log n)</strong> Comparisons, <strong>O(n)</strong> Auxiliary Array<br>
Rather than performing any swaps, a much more effective method of sorting is to use a Merge Sort. This algorithms breaks each 
node into it's own "sorted array" of size 1. Comparing each array with the first element of its neighboring array, it pulls
the lowest node (and moves to the next node if the array size is greater than one) then pulls the remaining nodes least to greatest to a new array. 
This new sorted array is twice the length of the previous array. Repeating this process until the sorted array is of size <em>n</em>. In my opinion this may
not be the most elegant solution as it requires an auxillary array to hold the nodes as they are being sorted.
<br><br>
<u>Quick Sort</u> - <strong>O(n log n)</strong> <br>
Is probably the most effective sort covered in this study. The way this one works is to choose a node from the array at random.
(Ideally close to the median value) This value become the "pivot". The array is split into two new partitions on each side of the pivot. 
The partition on the left side of the pivot is iterated until a vaule is found that is greater than or equal to the pivot. Then the right 
side partition is iterated until a value is found that is less than or equal to the pivot. Once each side has found a value, the nodes are swapped.
Continuing this process will put all nodes less than the pivot on the left side partition, and the nodes larger than the pivot on the right side.
This ensures that the pivot is in the correct place of the array. A pivot is chosen in the left and right partions and new sub-partitions are created.
The divide and conquer type of sorting seems to be the quickest method.
<br><br>
<u>Heap Sort</u> - <strong>O(n log n)</strong> <br>
I found this algorithm to be the most fascinating in it's approach to the task of sorting. The way a heap sort works is to 
first organize the nodes into a tree data structure called a heap. The structure of the heap is such that each parent node 
is parent to two children nodes that are smaller than the parent, these child nodes follow the same structure until the entire array is "heapified".
The heap is stored in an array as follows <br>[0,1,2,3,4,5] - 0 is a parent of 1 and 2, 1 is a parent of 3 and 4, and 2 is a parent of 5.<br>
The formula for finding relationships to current node at index <em>i</em> is:<br>
<code>
iParent(i)=floor((i-1)/2);<br>
iLeftChild(i)=2i+1;<br>
iRightChild(i)=2i+2;<br>
</code>
Once the the array is heapified, it is simply a matter of pulling the top most node and swapping with the last element in the heap.
Once the smallest node is at the top, you swap with the larger of it's two children until the heap data structure is satisfied (being that the children of the node
smaller than the parent node). You then continue pulling the top node until the list is beautifully sorted.
<br><br>
Source code is provided below, it isn't incredibly effecient as is as it is used for the visualizer seen above. But I plan to add 
an implementable version of the sort methods. Eventually.<br>
SOURCE: <a href="https://github.com/sbacon-/SortAlgorithms"> /sbacon-/SortAlgorithms </a>

  </p>
    <script>
      var buildUrl = "Build";
      var loaderUrl = buildUrl + "/AlgoVisualizer.loader.js";
      var config = {
        dataUrl: buildUrl + "/AlgoVisualizer.data",
        frameworkUrl: buildUrl + "/AlgoVisualizer.framework.js",
        codeUrl: buildUrl + "/AlgoVisualizer.wasm",
        streamingAssetsUrl: "StreamingAssets",
        companyName: "chancho.dev",
        productName: "Sort Algorithm Visualizer",
        productVersion: "1.0",
      };

      var container = document.querySelector("#unity-container");
      var canvas = document.querySelector("#unity-canvas");
      var loadingBar = document.querySelector("#unity-loading-bar");
      var progressBarFull = document.querySelector("#unity-progress-bar-full");
      var fullscreenButton = document.querySelector("#unity-fullscreen-button");
      var mobileWarning = document.querySelector("#unity-mobile-warning");

      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        container.className = "unity-mobile";
        config.devicePixelRatio = 1;
        mobileWarning.style.display = "block";
        setTimeout(() => {
          mobileWarning.style.display = "none";
        }, 5000);
      } else {
        canvas.style.width = "960px";
        canvas.style.height = "600px";
      }
      loadingBar.style.display = "block";

      var script = document.createElement("script");
      script.src = loaderUrl;
      script.onload = () => {
        createUnityInstance(canvas, config, (progress) => {
          progressBarFull.style.width = 100 * progress + "%";
        }).then((unityInstance) => {
          loadingBar.style.display = "none";
          fullscreenButton.onclick = () => {
            unityInstance.SetFullscreen(1);
          };
        }).catch((message) => {
          alert(message);
        });
      };
      document.body.appendChild(script);
    </script>
  </body>
</html>
